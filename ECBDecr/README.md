
Note: работает только благодаря /noentropy (i.e. для каждого challengeID фиксированный ключ и random_padding в начале); иначе забрутфорсить тупо не получится из-за невозможности выровнять блоки.

Обобщенный алгоритм:
- Подобрать такую длину bogusText (состояющую из 'a'), чтобы граница блоков ШТ совпала с границей bogusText || target_data и запомнить индекс начала следующего блока (для верности, чтобы точно знать, что найденные блоки это ШТ именно наших блоков,bogusText состоит из 3 блоков 'a' и соответственно + n-ое кол-во 'a', в зависимости от размера random_padding)

Далее реализуем что-то типа ЛРС: 
- Берем новый блок открытого текста register(16, 'a') - он будет нашим регистром
- Удаляем из регистра последний символ (типа сдвигаем влево) и добавляем к шифруемому bogusText; в полученном ШТ получаем следующим блоком шифртекста блок ['a'..'a'] || target_data[0]. Сохраненный индекс будет указывать на данный блок; сохраняем данный блок как ожидаемое значение для следующего шага.
- Брутфорсом перебираем ASCII символы путем добавления в конец шифруемого текста один ASCII символ, пока полученный блок ШТ по тому же индексу не совпадет с сохраненным блоком. Как только подобрали - угадали [0] символ из target_data (т.к. ECB получит тот же блок, что шифровал в предыдущий раз, но теперь не из-за того, что он добавил к нашему передаваемому ОТ символ target_data, а потому что ровно этот же символ мы добавили сами к шифруемому тексту).
-  Добавляем угаданный символ в регистр (и в ответ) и снова сдвигаем; получаем register = 'a'..'a' (14 раз) || target_data[0] 
- Повторяем шаги 2-5, пока не вытолкнем все bogus символы ('a') из регистра; мы подобрали первый блок target_data. 

-- Чтобы получить новый блок target_data под индексом i, необходимо сдвинуть индекс, из которого мы берем ожидаемое значение, на i * BLOCK_SIZE, а в регистре ничего не стираем, оставляем как есть после первой итерации; при том же режиме работы регистра, в самом начале итерации i=1 (после сдвига регистра и отправке на шифрование), блок ШТ, состоящий чисто из данных target_data будет блоком target_data[1..16] (target_data[0]  в предыдущем блоке). А символы target_data[1..15] как раз в регистре! То есть повторяем те же шаги, только индекс блока другой.

`Сложность такого брутфорса 2^8 * BLOCK_SIZE * n, т.е. линейная от размера target_data, поэтому пойдет.
